## C#

### Variáveis

Em c# declaramos uma variável da seguinte forma: **tipo nomeDaVar**.

```C#
int myInt = 0;
```

⚠ _Devemos sempre inicializar uma variável, assim que ela for declarada._

O gerenciamento de memória em C# é feito em duas áreas de memória: **Stack** e **Heap**.

* **Stack:** Small space of memory (KB), that works just like the name suggests: like a stack/pile of data. This type of data structure is known as LIFO, which means that the Last element in is the first element out.  The data types in a stack are called **Value types**(numbers, floating points, decimals, booleans and structs), and any data inserted in a stack is automatically removed after the end of the process that allocated it. When a stack reaches its maximum capacity, then we have a problem that is called **stack overflow**.

* **Heap:** Unlike the stack, the heap is a larger memory space that has its size increased as needed (dynamic). The data inside the heap are passed by reference, being so called **reference types**. _The garbage collector is responsible for cleaning this area_. The cost of an object in heap is higher than in the stack, therefore, inside the heap memory we keep **classes, interfaces and delegates**.

**Properties of value types:**
* Hold values, not memory address reference.
* Derivative from System.ValueTypes;
* Local scope variable need to be assigned before used.
* A copy of the content of a variable is made when we, implicitly, assign a value from one to another. This won't change the variable's content.

**Properties of reference types:**
* Hold references/address to the object tha is in the heap.
* Made copy of the object address when a content of a variable is assigned to another, without high performance costs.
* Are passed by reference. That means, if an object is modified, than all instances that points to that object also will be modified.

### Boxing

Is the conversion of a value type to reference type.

```C#
int i = 10;
Object obj = i;
```

### Unboxing 

Is the opposite of boxing. It gets the value type of an object and parses into a simple object.

```C#
Object obj = 10;
int i = (int)obj;
```

### Garbage Collector(GC)

It get rid of variables, in the heap, that don't make references to objects anymore.

⚠ It is considered a bad practice to call the GC manually.

```C#
GC.Collector(); // calling the GC
GC.WaitForPendingSinalizeers(); // waiting for the end of processes
```

### Passing Values or References

```C#
static void Main(string[] args)
        {
            void FuncaoPorValor(int numero)
            {
                numero = 10;
            }

            void FuncaoPorReferencia(ref int numero)
            {
                numero = 10;
            }

            int variavel = 0;
            FuncaoPorValor(variavel);

            Console.WriteLine("Resultado = " + variavel.ToString());
            Console.ReadLine();
            /// resultado = 0

            int variavel2 = 0;

            FuncaoPorReferencia(ref variavel2);

            Console.WriteLine("Resultado = " + variavel2.ToString());
            Console.ReadLine();
            // Resultado = 10
        }
```

The main difference is that one passes the `number` variable passed by its value (i.e. passes the value of the variable), and the other takes the reference (i.e. adress of the variable) of `number`.

Usually, when we pass a variable to a function, in fact, we are assigning a copy of that vaiable to that given function. If that copy is modified, the original variable remains the same.

When this value is passed by reference, a pointer of memory are being passed in, and any changes that we make will affect the variable.

### Loops

